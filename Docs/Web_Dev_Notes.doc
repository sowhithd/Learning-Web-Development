Ueful Extension for browser for coding and other Purpose:

HTML Tree Generator: Which gives the DOM Tree of a website
MERlin: AI tool used for all purposes.
Selecttext: Which helps to copy content from a video
Pesticide for Chrome: Helps us to know about HTML and css details for a website(hint: From keyboard press ctrl and hover on the context to know details)


HTML: HyperText Markup Language

HyperText: 
* It refers to the pieces of text which can link other documents in the website.
* These pieces of text are hypertext/hyperlinks, they are the foundation of how HTML website works.
* Consider a example in browser has the hyperlinks onClick of that the page connects to other
  HTML document/file.

Markup Language:
* In English Language we ofen see like below
  "This is quote"
  like this double quotes which acts as similar to Markup. The presence of the quotation marks tells
  a reader that this is a quotation.
* Similar in HTML Markup Language is achieved through HTML tags.

Note: Breif about HTML tags added in project folder "HTML tags screenshot".

Difference b/w Tag and Element:

Ex: <h1>Hellow World</h1>

Tag:
We call h1 as tag. Anything that is inside in an Angle bracket we call these Angel brackets is a tag.
<h1>: called "Opening tag"
</h1>: called "Closing tag"

Element:
The entire h1 tag and content added b/w the Opening and Closing tags. Called HTML Element.

Void Element:
It is an element where we are forbidden from putting any content inside the tag.
Ex: <hr/>, <br/>


Characters or symbols such as the less than sign (<) or greater than sign (>) are known as reserved 
characters in HTML. 

You cannot directly use these reserved characters in HTML codes because the browser may 
interpret them as tags. 

Therefore, in order to use such reserved characters in HTML codes, you must include "character entities". 

Apart from the reserved characters, you can use character entities in HTML codes to represent currency, 
mathematical, or technical symbols that are not there on your keyboard.

Character entities are also known as HTML entities. 

Each entity is identified with a name and number. 

Entity names are case sensitive. 

The syntax to write a character entity is as follows:
&entity_name;
OR
&#entity_number;

-----------------------------------------------------------------------------------------------------------------
In a single HTML page, you can use all the three ways of Cascading Style Sheets (CSS) - inline styling, internal style sheet, and external style sheet. However, there is a defined order in which the CSS is executed.

Inline styling has the top precedence. The browser will first apply the inline styles in case of conflict or repetition of styles.
External style sheet has the second precedence.
Internal style sheet has the lowest precedence.

Consider this example. A HTML page has an internal style sheet where you have defined the background color 
of the page. 
For the same page, you have defined another background color using inline styling for the <body> tag. 
You have also defined another background color for the page in the external style sheet.

On executing the page, the inline styling will take the top precedence, followed by an external 
style sheet, and finally the internal style sheet. 
Thus, the final background color of the page will be set according to inline styling.




CSS:

* One pixel is about 1/96th of an inch.(1px = 1/96th of an inch = 0.26mm)

* One point is about 1/72nd of an inch.(1pt = 1/72nd of an inch =0.335mm)

* 1em(pronounce as m) is 100% of parent tag width.
  * 1em is defined as the full width of an M.
  The letter M is probably one of the widest letters in the English alphabet, 
  and this unit simply represents that entire width.

* 1rem is 100% of root element tag.

* sans serif  is a generic font typeface. It is simply the type of font where all the edges are pretty much at right angles.

* If you see decorative lines or tapers (also commonly referred to as “tails” or “feet”). 
  Then very often what you're looking at is a Serif  genetic font typeface.
  When you're choosing a Serif typeface you're making your design look more serious, more authoritative 
  and also a little bit older as well.

* Having this generic typeface. This means that when you have this set that Mac users will see this font, 
  but Windows users will see something that's relatively equivalent and it will be automatically displayed for them when it doesn't work.

* The full form of vh is "viewport height". It works like the percentage unit as well. 
   Specifying 10vh is equivalent to occupying 10% of entire visible screen height.
   If we mention 50vh means 50%, which will cover half of the entire screen height.
   (50vh === 50%)

* The full form of vw is "viewport width". It works like the percentage unit. 
  Specifying 10vw is equivalent to occupying 10% of entire visible screen width.
  If we mention 50vh means 50%, which will cover half of the entire screen width.
   (50vh === 50%)



Based on the way the Cascade works.

There are four broad categories which we look at when we're determining the overall level 
of importance of css rule.

Example Order mentioned below is the last applied rule to an element:

Position:
Ex:
li {
  color:Red;
  color:green
}
green color is the applied rule for the element.

Specificity:
Ex:
li {color:blue}
.first-class {color:Red}
li[draggable] {color:purple}
#first-id {color:orange}

Type:
Ex:
<link rel="stylesheet" href = "./style.css">
<style></style>
<li style="">Hello</li>

Importance:
Ex:
color: red;
color: green !important


CSS Position:

Static:
  * Static positioning, and this is actually the default.
  * As soon as you insert any piece of HTML by default, they're going to have this particular 
    positioning applied to them.

Relative:
  * Relative positioning takes the static position and then you can move it relative to that location.
  * It's relative to its supposed location.

Absolute:
  * Position Relative to nearest positioned ancestor. 
    If the above rule didn't match criteria it goes with below rule 
  * Top left corner of webpage.
  * The tricky thing about the absolute positioning is you have to make sure if you want 
    it positioned relative to another item, you have to set that ancestor to have position relative. 
    Otherwise it's going to default to positioning relative to the top left of the web page.
  * In Absolute Positionning the element moves up and down if you scroll.
  * Z-index: Everything on screen has a default Z index of zero.

Fixed:
  * Position that is going to be relative to the top left corner of the browser window.
  * Similar to Absolute positioning it default to top left of webpage but its going 
    to be defaulted to browser.
  * That means is that even if you scroll up and down on the web page, it's still going to be
    located in the same location relative to the browser. 

 Css Display:
 
 When we set "display property to none", then what that's going to do is it's going to make 
 any element on the screen basically disappear.
 
  inline:
  * Important things to remember about elements which are inline in their display is you
    can't actually set the size of these elements.
  * You can't set the width and the height.
  * If we had a much longer sentence then your inline element would stretch to fit that size.

block:
  * When an element has display set to block, then it's going to take up the entire full width.
  * Now, this means that if you have another element, then it's going to go below it and 
    it's not going to go onto the same line.  

inline-block: 
  * As element has this inline-block then block aspect allows us to set the height and width.
    And the inline aspect of the setting allows us to have elements that go on to the same line.


CSS Float:
* Is to wrap text around a particular element.

Flex:
* The main idea behind the flex layout is to give the container the ability to alter its items’ 
  width/height (and order) to best fill the available space (mostly to accommodate to all kind 
  of display devices and screen sizes). A flex container expands items to fill available 
  free space or shrinks them to prevent overflow.
* Flexbox is really good at is allowing you to create 1D layouts, whether if you want everything
  laid out as boxes on the horizontal or if you want everything laid out vertically as boxes on 
  the vertical, then you're probably going to be using Flexbox for this.

* By default, this flex direction is set to row
* It's going to be stacked on one after the other onto the same row until there 
  is no more space and it's still going to try and continue to stack 
  it from left to right in Flexbox.
* Flexbox provides one of the easiest ways to center an item inside another container.
* when you have a flex direction set to row, then you're setting something called the main
  axis. (It's going from left to right and it's on the horizontal)
* The cross axis goes perpendicular to the main axis, means in this case where flex direction 
  is from "top to bottom".  
* The algorithm essentially that Flexbox uses to determine each of the flex items size 
  is based on piority list
  pattern: Content Width < Width < flex-basis < min-width/max-width (starts from right to left)
    * Intially if we nothing set on flex item algorithm will default max width and min width 
      that's set based on the content. This is called Content-width.
    * The default for flex basis is actually auto before applying width it's going to look at the 
      amount of content in each of the items and it's going to apply more flex basis to the items with more content.
    *  We can also manually set each of these properties and completely ignore the text content.
    * Few Scenarios:
          Max-width:
          * Let's say that we had a flex basis of 200 pixels set on each of the items, 
            but we go ahead and also set a maximum width of 100 pixels. 
            {
              flex-basis: 200px;
              max-width: 100px
            } 
            In this case the width applies to items is 100px even as per alogrithm piority flex-basis
             should be applied. Due to the value of max-width is smaller than flex-basis.

            But if the flex basis was smaller than the max width, for example, 
            if we had a flex basis instead of 200, it was 50 pixels.
            {
              flex-basis: 50px;
              max-width: 100px
            } 
            Well then in this case each of the items will actually be 50 pixels.
            Instead, the maximum width it will be flex-basis.
          Min-width:  
          * Let's say that we had a flex basis of 200 pixels set on each of the items, 
            but we go ahead and also set a minimum width of 300 pixels. 
            {
              flex-basis: 200px;
              min-width: 300px
            } 
            It's actually going to apply the minimum width, even though we have a flex basis
            because the minimum width is larger than the flex basis.


Grid:
* GRID is something that applies to 2D layouts, where you've got columns and you've got rows.
* The default behavior for a grid container is to try and take up the full width of the window, 
  but only have as much height as it allows to fit the content so we don't have to change the height.
* When we create and size our grid, we create rows and columns these are collectively known as "tracks".
* We have row tracks and column tracks. And we usually create and size these tracks using 
  grid template rows or grid template columns.
* Within the intersections of the tracks. We create small units which are called a "grid cell".  
  They are the smallest unit in a grid and they can be different sizes.
* We have horizontal lines and vertical lines, and those are called the grid lines.
* We can only control the grid lines by using that "Gap property" to specify its height or width.
  The use of "Gap property" is we don't have to use padding or margin to separate the items in our grid.
* By default, our grid is going to lay out our items into the unoccupied cells, one item per cell.   
* By default, each of the grid items inside a grid container by default have a order of zero.
* And for the order property the grid item direction goes from left to right and then top to bottom.
* Important to keep in mind when you're using grid area is if you're going to use grid area 
  on a particular item. Then for all rest items grid area property to be used to keep the all
  align correctly.



  CSS BootStrap:
  Layouts:
  * The most powerful features of Bootstrap, which is the 12 column layout system.
  * The 12 column system is made of three components.
      * Firstly, we need a "div that has a class of container" and this is going to be the starting point.
      * Second for that container class div, we need another div which is going to be of class row.
      * Inside row is where we will have our items and they will be laid out using the column system.
 Ex:
  <div class="container">
    <div class="row">
        <div class="col">Hello</div>
    </div>
  </div>     
  
  * When you have multiple columns laid out inside the row, automatically Bootstrap will try to give 
    every column inside the row equal spacing and space them across the entire width of the container.
  
  * One of the great things about bootstrap breakpoints(See in important images folder "Bootstrap breakpoints details img") 
    is we don't really need the media queries as much because this covers pretty much a lot of the different device dimensions 
    and we don't have to manually write all the pixel sizes and add media queries into our CSS.

 * col class by default is going to take up 100% of the width in the small sized screen.   

BootStrap Layout Excersise:
https://appbrewery.github.io/bootstrap-layout/

Answers:
1). <div class="col-xl-6 ">50% desktop, 100% mobile</div>
    <div class="col-xl-6">50% desktop, 100% mobile</div>

2). <div class="col-lg-6 col-sm-12 col-10">Column 1</div>
    <div class="col-lg-3 col-sm-6 col-10">Column 2</div>
    <div class="col-lg-3 col-sm-6 col-10">Column 3</div>

3). <div class="col-xl-2 col-lg-4 col-md-6">Column 1</div>
    <div class="col-xl-10 col-lg-8 col-md-6">Column 2</div> 



User Interface (UI):
As per user the content in the website should be easily understandble by highlighting the important points
To achieve that we can follow the below rules:
1). Hierarchy:
  -- We can establish hierarchy in a number of ways. The most obvious is through the use of color.
  -- Now in addition to color, you should also think about size because the bigger items often draw your eyes to it.
2). Layout:
  -- In addition to establishing hierarchy in terms of user interface, we should think about the layout of the website.
  -- We want to aim for something around 40 to 60 characters per line so that it feels comfortable to the user and they'll 
     be able to get through the information and still be interested in your website.
3). Alingment:
    -- This has to do with how you position each of the elements on the screen relative to each other.
    -- One of the easiest ways of making any sort of design you create look professional is just to reduce the number 
       of alignment points.     
4). White Space:
    -- It is important concept in design. It refers white space that's aroung text/ elements.
    -- By adding that space around each element on the screen you can make your design a lot more minimalist 
       and at the same time elevate it.
5). Audience      


User Experience (UX):
* We often think of having an aesthetic (concerned with beauty), what we think looks good and enforcing that on the user. 
  Now user experience is meant to be invisible.
* If you have a good experience with a website it just lets you do your thing and it feels like as if everything 
  is easy and everything is effortless.
* Now some designers though use the knowledge they have about human psychology and User Interface and
  User Experience design to do bad things. And in the design world, we call these "dark patterns". 
  So patterns which get a user to perform an action or behavior that is beneficial to the company or the designer 
  but it's not necessarily what the user wants. And it is another form of bad user experience.

1). Simplicity:
  -- Keeping things simple is always better than making it more complex or more cluttered.
  -- Whenever you're having to choose, should I make it more complex or should I make it more simple,
     always try to pare it down(it has unnecessary features, and has been reduced to a very simple way).
2).Consistency:
  -- Keep your designs consistent but also keep the functionality of your product consistent.

3). Reading Pattern:
  -- "One of the most common reading patterns is what's called the "F-pattern" where the eye starts at the
     top left of the corner and then it tracks the right and then it flips back again".
  -- We can this pattern using "F-layout". So, have the most important parts of your content on the left gutter, 
     have the logo at the top and have everything follow this pattern.
  -- Another really common pattern for reading is the "Z-layout" where our eyes go from left to right and then
     zigzagging down all the way the website.
  -- This depends on the type of website for ex: If somebody is trying to browse a website a little bit faster seems to be
     using the "Z-layout" pattern. This is pretty famously used in Facebook.
  -- Using that Z-pattern to accommodate for people's natural reading pattern.         

 4). All PlatFrom Design:
   -- Now in today's day and age, it's really important to think about All Platform Design.
   -- It's not enough anymore to just design a website that's meant to go into a desktop computer.
      Instead you have to think about mobile as well. 
   -- So having a website that scales up nicely onto mobile, what we call mobile responsive, is really important and vice versa. 
   -- And try to avoid  pet peeves (something that a particular person finds especially annoying.) in terms of design 
      which is having so many banners on your website that show up on the mobile version that your content becomes impossibly small.


* There's a website called Daily UI which gives you a task to design every day for 100 days.  It's free to sign up and 
  it's something that really does improve designing skills by just that repeated practice.
  URL: https://www.dailyui.co/ 



CDN:
 * Which stands for Content Delivery Network. These are little hubs all across the entire world and it knows where your users are located.
 * When they load up your website and try to access this particular files that contains all of the content.
 * Then it can find the closest location with the shortest distance to the server that has that content.
 * That means even though this has to be downloaded from somewhere, it can be delivered to your user and rendered very, very quickly.
 * From developers point of view as , all we need to do is simply include this link into the header section of our HTML.    

JavaScript: 

* Brendan Eich created JavaScript in 10 days. Initially it was called "LiveScript". Later Europeans decide to strandardize the language and
  called "ECMA (European Computer Manufactures Association) Script".
* JavaScript is a Interpreted Programming Language. Ex: JavaScript, Python, Ruby.

What is Middle-Squares Method?
The middle-square method is a simple way to generate random numbers. It involves creating an n-digit starting value, squaring it, 
and then returning the middle n digits as the next number in the sequence.

Math.randon() function generates 16 digit decimal number, and it can be any number between 0 to less than 1.

Important to remember in Array is
array.push() => It always pushes the item that you have into end of array. It doesn't push it in randomly into the array or at the
                begining of the array. This is a really easy way of adding items into array as needed.

array.pop() =>    It always take the last item and it will remove it from the array.


Document Object Model (DOM):
 * It basically catalogs the web page into individual objects that we can select and manipulate.
 
 * The task of converting an HTML file into the DOM is done by the browser when you load up the web page. And what it does 
   is that it turns each of these elements and their associated data into a tree structure with a whole bunch of 
   objects that you can select and manipulate.

*  A tree model is usually how you'll see the DOM represented. You can see that all of the elements 
   in our HTML has been converted into objects, and their relationships to each other mapped out in the tree diagram.

*  Entire tree is contained inside an object called the document.

*  Objects inside the DOM can have properties and methods. Now properties describe something about the object and the methods 
   are the things that the object can do. 



Seperation of Concerns:

When we are writing code for websites, in order to keep our code tidy and easy to debug, we have to keep in mind the idea 
of the separation of concerns at all times. And what this means is that: 
* HTML is for content only. 
* CSS is there to style your website 
* JavaScript is there for behavior.



Higher Order Functions:
Higher order functions are functions that can take other functions as inputs.

Ex:
function add(num1, num2) {
 return num1 + num2;
}
function multiply(num1, num2) {
 return num1* num2;
}

//Here opeator parameter take other functions as input
function calculator(num1, nun2, operator) {
 return operator(num1, num2);
}

//function call:
calculator(2,3,add);
calculator(4,5,multiply);



jQery:
* John Resig known as the creator and lead developer of the jQuery JavaScript library.

* Most popular option across the web/internet is to use Google's CDN (https://developers.google.com/speed/libraries#jquery).

* The beauty of using a popular CDN is that "if a user opened an another website that uses the same CDN which you have added to your 
  website to fetch the jQuery library, then they'll likely have it already cached and saved in their browser, which means that 
  when they want to load up your website they won't have to fetch a fresh copy of jQuery, they've already got it loaded and ready to 
  use the same downloaded one, giving your web site a much faster load rate.

* The on() method is used to attach one or more event handlers for selected elements. It provides a way to attach event handlers 
   for various types of events such as click, hover, keypress, etc., to elements in the DOM. 

* The on() method also allows attaching event handlers to dynamically added elements, which is particularly useful 
  when working with dynamically generated content.
  Syntax: $(selector).on(event, childSelector, data, handler);
   
  * event: Specifies the event to attach the handler for (e.g., "click", "keypress", "mouseenter", etc.).
  * childSelector (optional): Specifies a selector for filtering descendant elements that trigger the event.
  * data (optional): Data to be passed to the event handler as event.data.
  * handler: A function to execute when the event is triggered. This function receives the event object as its argument.


  Ex:
   For <button id="myButton">Click Me</button>

   
    $(document).on("click",'button[id ="myButton"]',{param1: 'value1', param2: 'value2'} ,function(event){
        // Accessing event data
        console.log('Event Data:', event.data);
        
        // Accessing other properties of the event object
        console.log('Target:', event.target);
        console.log('Type:', event.type);
        
        // Your event handler code here
        alert('Button clicked!');
    });






Bash Shell:
* To understand the Bash shell, we first have to know what a Shell is
* In Shell Kernel is the core, in computing kernel refers to the actual program that interfaces with the hardware. Sp, its core of the
  operating system.
* Now the Shell in computing refers to the user interface for you as a human to be able to interact with the kernel and in turn 
  with the hardware of your computer.
* There's two variants to the shell.
  -- Graphical User Interface
  -- Command Line Interface  

* Now the one we are going to use "Bash Shell", it is a Command Line Interface for Unix system.
* Bash Shell stands for "Bourne Again Shell". It is named after  Mr.Bourne.
* With the command line, you have full control and you have a lot of flexibility.


few Bash commands:
cd ~        --> moves to root directory
cd ..       --> moves one step back to parent folder
cd '<Path>'  --> moves to mentioned Path
cd <Directory_namae>: --> moves to the mentioned directory Ex: cd d:
touch <file_nane> --> to a new file ex: touch test1.txt 
start <file_nane> --> to open a  file ex: start text1.txt
rm <file_name> --> to delete the file
rm * --> to remove all files from directory
rm -r <Directory_name> --> to remove the entire directory
rm -rf <Directory_name> --> to remove the entire directory. In command 'f' means to do delete operation on Force it won't ask confirmation


In Mac we use sudo before any command. "sudo means SuperUserDo".




Node.js:
* It's actually not quite a framework. 

* It's, "An asynchronous event-driven JavaScript runtime.

* Node.js is designed to build scalable network applications.

Initially when JavaScript was created it was desined to run in  only browser. This means that it was impossible to use JavaScript 
to write any kind of program that's not a website.

Node Uses V8 engine which comes from chromium written in c and c++. It is fast and boost the chrome browser.

When Node came long it effectively liberated the JavaScript out of browser and gave it the freedom to allow us to use it to 
write any sort of application, desktop or server side.

"Node provides us with this "JavaScript runtime" so that we can run JavaScript on a machine such as your own local computer, then 
it means that we can use JavaScript to accomplish pretty much anything that other popular server side languages 
like Ruby, PHP, C-sharp, Python can do, but maintaining our full JavaScript stack from frontend to backend."

Asynchronous means that your JavaScript code doesn't have to do everything sequentially.

 Node, on the other hand, is asynchronous and it's event driven, so it means that you can add the code blcok to an event and we
 can initiate that code block when the event is triggered.

 "In summary, the reason why we need Node is because it allows us to build an application often on a computer using JavaScript."

 Why are we choosing Node?

 * Well, the reason is because if we use Node, which is one of the most popular choices as of today, then it means that our 
   frontend could be written in JavaScript plus HTML and CSS of course, but our backend could also be written in JavaScript,
   and this allows us to use one language to rule them all.

* So the key benefits of Node.js are the fact that it allows us to use JavaScript across the entire stack, which means that 
  developers are using a language they're already familiar with, and it makes it easy for them to transition 
  from frontend to backend developer. 

 * Node.js allows for easy Scaling of applications, making it really good for large-scale professional projects.

 * It's fast and it's Non-blocking. Because of this asynchronous event-driven nature of Node.js, it can be really fast 
   and really efficient, instead of having to wait for things to happen or blocking the resources.


   Node REPL:
   REPL stands for Read Eval Print Loop.
   * It is a computer enviornment where user inputs are read and eveluated, and then the results are returned to the user.
     For ex: In node runtime environment where we can put in user inputs in the form of code, and what we write is read by the 
              computer and evaluated line by line, and then it prints out the result back to us in the command line or in the console
   
   * This is not unique to Node. It's something that we can do with most programming languages.

   * In node to initiate REPL. All we have to do is to type the command "node".

   In Webiste https://nodejs.org/docs/latest/api/fs.html. If we notice for any example code snippet has a toggel button called "CJS and ESM".
   
   CJS: CommonJS, this was the method using, "require" that we used to use to get hold of Node modules, native node modules 
        or even NPM modules. 
   Ex: const fileSystem = require("fs");
   
   ESM: ECMAScript modules
        Since version 12 of Node, we've moved on a little bit, and Node is now enabled to use ECMAScript  modules.
        So instead of using require, we can use the "import" keyword.
  Ex: import * as fs from 'node:fs';    

  In JavaScript, ES modules, also known as ECMAScript modules, refer to the official standard format for packaging and organizing code.
  They offer a structured and modular way to break down your codebase into reusable units, promoting better code organization, 
  maintainability, and collaboration. Here's a comprehensive explanation of ES modules:
   
Key Features and Benefits:
* Import and Export Statements: 
    ES modules rely on import and export keywords to define dependencies between modules:
      * import: Used to import functionalities or variables from other modules.
      * export: Used to export functionalities or variables from the current module to be used by other modules.
* Static Scoping: 
    ES modules adopt static scoping, which means variables are declared within a specific module and are not accessible from outside 
    that module unless explicitly exported. This helps prevent naming conflicts and unintended side effects.
* Dependency Management: 
    ES modules inherently promote improved dependency management, as modules explicitly declare their dependencies through imports, 
    making it easier to track and identify dependencies within your codebase.
* Improved Reorganization: 
    With modular code, you can easily rearrange or remove modules without affecting other parts of your application as long as 
    dependencies are managed correctly.
Bundling and Transpilation: 
    ES modules are compatible with bundlers like Webpack, which can combine multiple modules into a single file for efficient browser 
    loading. Additionally, they can be transpiled (converted) to a format compatible with older JavaScript environments that 
    don't support modules natively.

Comparison with CommonJS:
* Prior to ES modules, CommonJS was a widely used module format in Node.js. However, it had limitations like dynamic loading and 
  potential naming conflicts.

* ES modules address these issues, offering a more standardized and consistent approach to modularity.

Current Ecosystem Support:
* All modern browsers and Node.js versions (starting with Node.js v12.10.0) natively support ES modules.
* For older environments, transpilers like Babel can be used to convert ES module code to a compatible format.


 Node Package Manager/NPM:
   * Basically a place which collects modules that people have built for Node and it's created by the GitHub organization and 
     it's a really great place to find code that other people have written with utilities and tools to help you with 
     writing your Node applications.

  *  NPM is kind of like a community tool library.
  
  * It's open source (https://www.npmjs.com/) and you can search to find all the packages that other developers have created, little
    tools that they've written the code for, that they think might be useful for other developers in the future, so that you 
    don't have to duplicate the work and to write everything from scratch.

  * NPM comes pre-bundled with Node, so if you have Node installed, you will also have NPM installed.  
  
  * npm init: This command brings up the initialization utility, which is going to help us create our configuration file, which is 
              called the package.json.

   * npm init -y: we are telling in command yes to every single question in that initialization script to create in Package.json.          
  
  * Package.json comes from NPM but effectively acts as a configuration file for our project.

  * To use the "import" keyword in our js pages. We need to configure that setting in package.json 
    page and the setting is "type:"module".
  
  * If we don't specify the setting the commonJs will be the default configuration for the project.


ExpressJS:

* Express Framework, the framework that's built on top of Node that's going to help us create our backends with ease.

* It  is actually a JavaScript framework that allows us to create backends for our websites.

* It uses JavaScript and Node to create a website in backend,  but it is souped up(having increased power and efficiency ) and it
  makes the whole thing so much quicker and so much easier.

* Localhost is simply when we don't have a server on the internet and instead we want to host our server locally, so making 
  our own computer the server for our website's backend. And that is the local part of our hosting.  

* The port is kind of equivalent to a bunch of doors on our server computer, and each of these doors have an address.  

* Command used to check which ports on our computer are currently  listening for interactions from the outside 
  command: netstat -ano | findstr "LISTENING"

* Here every time when we make some changes in js page we need to stop and start server again. Instead what we can do is we can
  use one of the node-module called "nodemon". This will restart the server automatically when it detects any changes done in js page.
  And will install it globally "node i -g nodemon". Then just type "nodemon app.js" instead of "node app.js".

Hyper Text Transfer Protocol:(HTTP)
* Basically describes this as a language, a language that allows computers to talk to each other across the Internet. 
* Details about status code available in here : https://developer.mozilla.org/en-US/docs/Web/HTTP/Status



MiddleWare:

* It kind of is something that just sits in between the raw requests that come in.

* When a request comes into the server and before it gets processed by all of the route handlers, such as our GET, POST, PUT, 
  the functions that we've planned for how to deal with a particular request there is something in between namely the 
  Middleware that can work with these requests before they get processed and reach their final destinations.

* When we know that a request is going to go to multiple handlers, maybe it could be processed by GET, POST or PUT, this intermediate 
  stage where we have our middleware can actually go ahead and change aspects of the request or perform various functions 
  on that request before it goes to its final routing.

* We can use Middleware for
  * For Logging the request
  * To Authenticate the request
  * Can Process any errors in the request.

* Commonly used middleware in Node and Express back-end engineering are:
  * "Body Parser"(https://www.npmjs.com/package/body-parser). Body-parser used as middleware to parse the information 
     that comes from HTML forms. 
  * Commonly used logging middlewares for Node is a package called morgan (https://www.npmjs.com/package/morgan)


Embedded JavaScript(EJS):
* A popular template engine for Node. js and web development. 
* It allows you to generate dynamic HTML content by embedding JavaScript code within your HTML templates.
* Well, essentially it's almost like having a little JavaScript module that can run JavaScript code inside a HTML file, 
  and it ends with the .ejs file extension.

Ex of index.ejs file:
<body>
  <ul>
    <% for(let i=0; i<items.length; i++) { %>
    <li>
      <%= items [i] %>
    </li>
    <%} %>
  </ul>
</body>


* To got the ejs intelligence window while writing code add the "EJS language support" extension in vscode application.

* locals is, is basically a way to access all of the variables that get sent over with a res.render.

Ex: 
code in index.js file, we are not passing any data in get method. Need to handle that null/undefined issue


app.get("/", (req, res) => {
  headingtext = "Enter Your name below";
  res.render(`${__dirname}/views/index.ejs`);
});

app.post("/submit", (req, res) => {
 var fullNameLength;

  if(req.body['fName'])
     fullNameLength = req.body['fName'].length;
  if(req.body['lName'])
    fullNameLength += req.body['lName'].length;

    headingtext = `There are ${fullNameLength} letters in your name`;
    
    res.render(`${__dirname}/views/index.ejs`,{numberOfLetters:fullNameLength});
});



locals is, is basically a way to access all of the variables that get sent over with a res.render. 

using the keyword locals we can get that get sent over with a res.render. 

code in ejs file:
Ex:
<% if (locals.numberOfLetters) { %>
    <h1>There are <%= numberOfLetters %> letters in your name.</h1>
    <% } else { %>
    <h1>Enter your name below 👇</h1>
    <% } %>



 * Normally what happens with Node-based backends is we create a public folder where we add in all of our static files, so maybe we 
   can put our images in there, our styles in there, our favicons, basically any file that doesn't change.   

 * In order to tell Express that is where our static files are located, we can use the middleware express.static and then 
   define the location or the name of our public folder.  

 * Basically once we've told Express where our public folder is, it will treat everything inside as a static file.
   That means when we create our stylesheet links, the href will be relative to the location of the public folder.  

 * We can use EJS for templating where we replace parts of our code using the EJS tags in order to insert bits of dynamic 
   content into the actual body of our code.  


API:
* Well, it stands for an "Application Programming Interface", and it's essentially a set of rules and protocols that define how 
  different software can interact with each other.

* Normally, you will have a base URL, something something.com, and then you will have a forward slash (/) and an endpoint.
  This endpoint can be different for different purposes.

   Ex: https://bored-api.appbrewery.com/random

* The next one is structuring a request is something called "Query Parameters". We've already seen the endpoint comes at the end of 
   the base URL. So this is the base URL, this is the endpoint and then afterwards we can add a little question mark (?) to say that 
   we are adding a query now to the end of this request.

  Ex: https://bored-api.appbrewery.com/filter?type=education

* Normally when you're hitting up an API, they're used for filtering, sorting, searching, and you can even have "multiple query 
  parameters" by simply adding an ampersand (&) after the first query. So remember, very important thing is in order to begin your 
  first query, you need a question mark and then you have your key: value pair, and then after the first pair, if you want to add 
  more queries, you tag them on starting with an ampersand  

  Ex: https://bored-api.appbrewery.com/filter?type=education&participants = 2


* So after the base URL, normally comes the endpoint, but an endpoint is usually a fixed path. But we can also have 
  something called "Path Parameters" where after a forward slash we can add some sort of parameter that does change, and this is 
  usually to find some specific resource that exists. So it could be an ID, it could be a username, it's basically something that's 
  very specific that can identify a resource in the API.

   Ex: https://bored-api.appbrewery.com/activity/3943506

Authentication:

In terms of authentication, it as four tiers.
* Zero Authentication

We can understand more by testing sample API's from here : https://secrets-api.appbrewery.com/
* Basic Authentication 
  * Well, you provide a username and password when you make your API request. Means that you are authenticating yourself 
    to the API provider. You have an account with the API provider, by providing these two pieces of information, you are 
    proving your identity.
   
  * Most API providers that use Basic Authentication will have HTTPS on their domain, which means that we're using cryptography 
    to securely encode all the data that being passed back and forth. And even if somebody intercepts the packets, they won't 
    be viewing the string using online webistes to decode the string.

  * But nonetheless it is still passing username and password, and if it's a less secure website or there is something that goes 
    wrong, then there is a risk there.   
  
  * Usually, the way that Basic Authentication is done is by passing over a "Base64 encoded string" in the header of the request.


    For Example using posman:
    As per this documentation: https://secrets-api.appbrewery.com/register, we need to register user while registering user
    pass JSON username and password data in body section with raw radio button selected of type JSON from dropdown 
                                          or
    created username and password parameters in x-www-form-urlencoded section

    Now to utilize this api https://secrets-api.appbrewery.com/all?page=1, we need to add the above created username and password
    in  Authorization tab. That value we see it Headers tab as Key value pair. Like keyname Authorization and value will be
    "Basic <Base64 encoded string>" which is converted automatically by postman

    To validate the key vlaue of "Basic <Base64 encoded string>". We can copy the string and paste in website https://www.base64decode.org/ 
    to see the decode vlaue which shows in format "username:password".


* API key Authorisation(UK terminology)/Authorization(USA)
 * This API key which can be deleted and regenerated. We can set the limit of API interactions say like  ex: 1000 API request a month.
   It can be adjusted if we upgrade subscription with API provider.

 * So even if somebody intercepts this API key, they won't be able to get hold of the username and password. They won't have any 
   of your payment details. It is just a reusable code that you're using to access an API.  


  Authentication:
    * If you have a user, they can authenticate themselves with your service. That means you are logging in or you are registering.

    * Authentication is something that allows you to be identified as a user to the API provider.

    Types:
    Ceaser Cipher:
     * A really simple example of encryption is something called the Caesar Cipher, 
       which is named after Julius Caesar.

     * This is an extremely simple form of cipher where we take the alphabet and we have an 
       encryption key.
     * The Caesar cipher is a very, very weak encryption method. It's incredibly easy to figure out 
        what the original text was, even if you didn't have a key.  
     * How this works? : In this the important part is "key" meaning how many letters to shift.
       Ex: I have secret text "troops in north" and I have a key of 3. Now the text encrypted to
           "wurrsv lq qruwk". Here each individual word shift to  3 letters. Meaning

           "t" shift to "w".
           "r" shift to "u".
           "o" shift to "r".
           "p" shift to "s".
           "s" shift to "v".
           
      * Here is the online link to see the Caesar Cipher: https://cryptii.com/pipes/caesar-cipher.

 AES256 Encryption:
 * In modern days, we use something far more secure, which is called AES 256,
   And this has a whole bunch of math applied, but at the end of the day, the essential process 
   is still the same.   

 * Now, there is just one weakness to this situation if we're thinking about storing passwords,
   and that is the fact that this type of encryption or this type of obfuscation is symmetrical.
  
 * So it means that if somebody happens to get hold of this super important encryption key and you 
   encrypt everything in your database using this particular method, AES 256, so no matter how 
   strong it is, if they get hold of this particular secret key, then everything else collapses 
    and they can work out encrypted text.

 * How this work? :
     * We have some plain text(ex: Troops In North) and then we have an encryption key(ex: Test), 
       which is something that you keep top-secret and you don't pass along with your text.

     * And we can go ahead and encrypt the string using AES, you can see that the 
       result(ex: 2PjL3YrLc50OLGFpAVmSRg==) is much, much longer.
  
     * It's very hard to work out how many letters the original text had, but if you were 
       somebody who's meant to receive this message and you receive it, and then you know that 
       the encryption key is then we can decrypt the encryptd message to view actual message.

   * Here is the online link to see the aes256 encryption: https://encode-decode.com/aes256-encrypt-online/



  At the moment, the biggest flaw in both discussed  authentication methods is the fact that we need 
  an encryption key to encrypt our passwords and decrypt our passwords.
  
  So, we need to keep this encryption key very, very secret. So, how can we address this weakest link, 
  the need for that encryption key?

  Well, here is where "Hashing" comes into play where as previously with encryption we needed that 
  encryption key, "hashing" takes it away and no longer requires the need for an "encryption key".

  Q).  How can we decrypt our password once it gets converted into a hash?
  Ans). Well, we can't. We use something called a Hash function to turn that password into a hash,
        and we store that hash in our database.
        
        Now, the problem is that hash functions are mathematical equations that are designed 
        to make it almost impossible to go backwards, so it's almost impossible to turn a hash 
        back into a password.
   
 Q).  So, how can we use hashing to solve this problem?
 ANS). So when a user tries to register on our website, then we ask them for the password, which
       we turn into a hash using our hash function, and then we store that hash on our database.

       Now, at a later point, when the user tries to log in and they type in their password, 
       then we again hash that password that user typed in to produce a hash, and then 
       we compare it against the hash that we have stored in our database.

      And if those two hashes match, then that must mean that the login password is the same as 
      the password given by user at time of registration. 


* Token Based Authentication:

 * Token-Based Authorization or authentication is even more secure because essentially we're getting the user to use a 
   username and password to log in and then once they've logged in, we generate a token to be used with the API.
   so, the API doesn't get involved with the username and password and instead it's the token that's constantly being used 
   to interact with the API.

 * Normally you'll see Token Based Authentication as "OAuth and OAuth 2.0" is probably the industry standard for doing token-based 
   authentication.  


Salt Password:
* This helps in prevent dictionary and hash table attacks.
* Salting takes the hasing the password a little bit further, in addition to the  password we 
  generate a random string called a salt, and then we hash the password and the salt together.

one that approach used to be to use a salt and then hash the password and the salt together. 
Used in below type:

Bcrypt:

* "Bcrypt" is a way for us to be able to hash our passwords using the "Blowfish algorithm", which 
  is a super secure, very modern way of ensuring that nobody with current computational skills 
  should be able to decode our password in a reasonable amount of time.

* This is one of the industry standard hashing algorithms that developers use to keep their users' 
  passwords safe. 

* It has a concept of what's called "salt rounds", how many rounds you're going to salt your 
  password with. 

* "bcrypt implementation flow":  Well, let's say that our original user password was "qwerty", and 
  we generate a random set of characters as the salt.
  So now we have qwerty and a random set of salt. We pass it through our hash function Bcrypt and 
  we end up with a hash, now that's "one round of salting".
  If we wanted to have two rounds of salting, then we take the hash that was generated in round one 
  and we add the same salt from before, and now we run it through Bcrypt the hash function again, 
  and we end up with a different hash. And the number of times you do this is the number of salt rounds.

* And for every increase in the salt rounds, the amount of time that it takes to hash your password 
  doubles. So, that means you don't have to change your hashing algorithm or update your code, 
  other than simply changing salt rounds number to keep up with the times.

* When it comes to checking their password, when they log in, we'll take the password that they
  put in from UI, combine it with the salt that's stored in the database for that user, and run 
  it through the same number of salting rounds until we end up with the final hash, and 
  we compare the hash against the one that's stored in the database to see 
  if they've entered the correct password. 

* we have a npm package for this called "bcrypt" . Here is the link: https://www.npmjs.com/package/bcrypt

* Because while you can calculate 20 billion MD5 hashes per second, even the latest and the greatest
  GPUs can still calculate only about "17,000 Bcrypt hashes per second", which makes it 
  dramatically harder for a hacker to generate those precompiled hash tables and a salted 
  hash table instead of taking something like three seconds if it was hashed with MD5.


Enviornment Variables:

* Environment variables are basically a very, very simple file that we're going to keep certain 
  sensitive variables, such as encryption keys and API keys.

* The filename will be ".env" this is strandrad way of creating the enviornment file.

* And everything is in all caps, and each word is separated by an underscore.  And then we have 
  an equal sign. And then we have a string enclosed in double quotes.

* That string is going to be whatever information is going to be associated with that name.

* The other thing to notice is that there's no space between the start and the end of the equal sign.

* And also, if you were to create another variable here, you don't have any sort of 
 commas or semicolons or anything, you just start it on a new line.

 Ex: PG_USER="postgres"

What exactly are these environment variables used for?

* One is for convenience. Normally when you deploy a large application, the process is quite 
  complicated. And once you've done it, you kind of don't want to mess around with the code base 
  and update the code files, instead, you could have these environment variables which you can change. 
  So certain variables that are being used in your code base could be set as environment variables, 
  and you could modify those variables without having to touch the code.

* Second reason might be for security. So when you're developing software, you might be uploading 
  your code base somewhere, and it's usually not a good idea to have things like your authentication 
  keys or your API keys to be stored in the same place as the rest of your code.
   


Password hacking Reference Links:
https://plaintextoffenders.com/about/  -- To now about the email that password has been comprised.

https://www.passwordrandom.com/most-popular-passwords -- MD5 hash passwords for common passwords

https://haveibeenpwned.com/ -- To find out the emailID got breached or not.

http://password-checker.online-domain-tools.com/ -- To check password is strong or not in online

https://en.wikipedia.org/wiki/List_of_the_most_common_passwords -- In this wiki it shows list of common passwords used in world

https://hackertyper.net/ -- To look like a hacker all we need to type something in keyboard




  Authorization:
   * Is simply a client who is allowed to use your service with an API key that might be associated with a user, in which case they 
     are authenticating themselves and then getting an API key to authorize themselves to use your API. 

   * Authorization is something that allows you to use an API.

OAuth:
* It's simply an "Open Standard for Token-based Authorization".

* So by using OAuth, we're able to access pieces of information on third party websites, such
  as their friends emails or their contacts on Gmail. if user choose to login with Google.

*   OAuth is quite special in three ways:

  * The first way is that it allows you to grant a "Granular Level of Access". Meaning that means 
    when your user logs in with Google, you can request specific things from their Gmail
    account. The app developer can determine what kind of data do they need from the user's account 
    and request those accordingly.
  
  * The second thing about OAuth is it allows for either "Read-only or Read-and-Write access".
    So in the case of Facebook, this means that you can either ask them to just retrieve pieces of 
    information about their account (ex:Facebook). Or you can ask for write access as well. 
    Say for example, in this case, if WordPress wanted to be able to post to Facebook on this user's 
    account, then they would need to ask for, read and write access. 

  * The third thing is that the third party that you're using to authenticate your users should be 
    able to Revoke Access at any point on their website. So, that means if you're authenticating 
    with Facebook, the user should be able to go into their Facebook account and de-authorize 
    the access that they granted to your website.

  How does this OAuth actually work in reality?  

  * So the first step is to actually tell this third party, be it Facebook, Twitter, or Google, 
    about our web application because they don't know about us.
    
  * So we have to set up our app in their developer console (ex: Google:  https://console.cloud.google.com/),
    and in return we get what's called an app ID or a client ID, and we or our website is then the 
    client, which will make the request to Facebook/Google to authenticate our user.  


REST API:(Representational State Transfer API)

What makes an API RESTFUL:

1). HTTP Methods:
    Is use standard  HTTP Methods like GET, POST, PUT, PATCH, DELETE etc.
    
2). JSON Output:
    It should probably have a standard data format that it responds with, meaning something like JSON format, XML format. Meaning  
    API response is given back to client  is in JSON format that is pretty standard.
    This is the Representation part of "Representational State Transfer". Resources are represented in a specific format like JSON, 
    and that is sent in response to the client.

3). Client - Server Architecture:
    Clients and Servers in RESTful APIs are completely separate. They are not on the same system or in the same file and they're 
    able to message each other over a network. In order to make requests and also to get back responses.
    This part of the RESTful API architecture allows each side to be able to scale independently from each other and they can 
    evolve and be completely built separately by different people, which means that the RESTful API allows the whole system 
    to scale very easily.

4). Stateless:
    The next rule is "Statelessness". What this means is that each request from the client to the server should contain all the 
    information that's needed to understand and process the request. So the server shouldn't be storing any sort of client side, 
    state or client side data between the requests.
    This means is that each single request can be completed, and each single response is also complete without need to know 
    what happened previously.
 
5). Resource-Based:  
    The next is that your REST, the API is "resource-based", so it is an API that is centered around resources and uses a "Unique 
    Resource Identifier, also known as a Resource Locator", so this is a URI or a URL, in order to locate specific resources.
    A Universal Resource Locator(URL), is simply just an address for a particular resource, and it'sa type of a 
    Universal Resource Identifier(URI). It identifies that resource in the API.


All above five rules seems kind of familiar just seems like the "internet". If that is the answer then it is true,  because the 
Internet as you know it, the World Wide Web is considered one of the most successful implementations of RESTful architecture.

In Internet:
* We have our resources located in URLs. So this is how we can identify what it is we want to access.

* We work and interact with the server through an API using HTTP standard protocol, and the responses we get back are 
  standard data formats such as JSON or XML, or JavaScript, or HTML

* Also we have a strict client / server separation. So the client is the person who's using the browser and 
  the server is the computer that holds all of the data that is needed to be served when somebody requests a particular web page.

* Internet is pretty much Stateless. Every single request to a web page contains all of the information that's required 
  in order to determine what web page to send back.

 JSON:
 * JSON stands for JavaScript Object Notation.  
 
 * Online Json viewer: https://jsonviewer.stack.hu/ 
 
 * It's a way to format data that can be sent over the internet in a readable but also efficient way. And as the name suggests, 
   it's structured after a JavaScript Object.
 
 * It is a string from the beginning to the end, and every single aspect of that notation is serialized so that it can be its minimal 
   size when transferred across the internet. The syntax keeps all of the meaning and then when it gets transferred to the other side 
   and when it needs to be used, it can then be re-expanded into a usable format such as a JavaScript object.

 * To convert JS Object to JSON. we need to use  `JSON.stringify()` method.
 
 * To convert JSON back to JS Object, we need to use `JSON.parse()`.

Axios:
* Axios is promise based, so we can either use ".then" or we can use "async await" in order to handle the response.

* There is an alternative way of calling Axios by chaining .then() to the end of the axios.get() method, we can also chain 
  a .catch() and we can also chain a .finally() as well. We can add multiple .then() methods.

  Ex:
     app.get("/noAuth", (req, res) => {
        axios.get('https://bored-api.appbrewery.com/random')
        .then((response)=>{
        var  content = stringifyRespons(response.data);
        res.render('index.ejs',{content});
      })
      .catch((error)=>(console.log(error)));
    });

* Between using a method like chaining the ".then()" versus marking the method as "async and then using the await keyword" before 
  we call something like axios.get() .


  Ex:
  app.post("/submit", async (req, res) => {
  try {
    const activityType = req.body['type'];
    const numberOfParticipants = req.body['participants'];
    const response = await axios.get(`${apiURL}filter?type=${activityType}&participants=${numberOfParticipants}`);
    const result = response.data;
     res.render("index.ejs", { data: result[Math.floor(Math.random() * result.length)] });
  } catch (error) {
    console.error("Failed to make request:", error.message);
    res.render("index.ejs", {
      error: error.message,
    });
  }
});


 * Both of these come from the JavaScript Promises API, but they work slightly differently:
    
    * The .then() method gets triggered once this promise gets resolved. So then it will wait until it's done and then 
      it'll look at the .then() and inside the .then() we can have another promise-based method .then() and we can keep chaining 
      these to happen in order.

    * The alternative is the more modern syntax which was introduced in 2017 as a part of the ES8 upgrade to JavaScript. And this 
      is formed by the "async and await keyword".



 NoSQL/non-SQL:
 * It is a database design approach that provides a way to store and retrieve data that's not modeled in the tabular relations 
   used in relational databases.
   
   There are four types of NoSQL databases:
   * Document databases: Store data as structured documents, such as PDFs, XML files, or JSON files
   * Key-value stores: A type of NoSQL database
   * Column-oriented databases: Designed to read data more efficiently and retrieve it faster
   * Graph databases: Organize data into nodes, with edges establishing relationships between these data nodes
 
 * One of the greatest things about NoSQL databases is you're able to change the structure of your data afterwards without 
   having to change the entire database. 
    * As an example we have data stored in JSON format related to user details. We can add an extra feild for only specific 
      user, we can modify our data on the fly, and this is what gives "NoSQL databases their flexibility".

  * Means it is not obliged to hold to the original structure of the table that was created at the time when you decided to 
    build a users table.     

  * Other thing that they really wanted to address is scalability. So for your data to be able to scale "horizontally(X-Axis) 
    and vertically(Y-Axis). So vertically means having more records, and horizontally means having more fields".  

  * Popular NoSQL databases we come across is MongoDB, Redis, DynamoDB (Run by Amazon).   



  Postgres:
 
 Table Create Syntax:

 CREATE TABLE flags (
id SERIAL PRIMARY KEY /*Here Key word SERAIL is similar to IDENTITY in SQL Server*/,
name VARCHAR(45),
flag text	 /*Imported csv has flag emoji's of UTF-8 data type. text data type because it handles little better*/
); 

To insert bulk data  into the table you can use following steps:
* In PgAdmin tool on click on  table we have option "Import/Export Data". 
* Select the file from the storage location. Make sure Impors is highlightened and checked
* Click on Options tab make sure "Headers Radio button is selected" 
* In Columns tab make sure the csv file header columns and DB table columns name are same including case sensitive. Those should be identical
 
where and like usage in Postgres:
SQL Query:
SELECT * FROM <Table_Name>
where <Column_Name> like '<String_To_Seach>' || '%' OR '%' || '<String_To_Seach>';